# 19 基本对象 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-fundamental-objects)

## 19.1 Object 对象 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object-objects)

### 19.1.1 Object 构造函数 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object-constructor)

Object 构造函数是 内置 %Object% 对象，是 [全局对象](http://www.ecma-international.org/ecma-262/7.0/#global-object) 的 **Object** 属性的初始值。当 **Object** 被当做一个构造函数调用时会创建一个普通对象，当被当做一个函数而不是构造函数调用时，它会执行一个类型转换。

**Object** 构造函数被设计成可以子类化的，它可以作为类定义时 extends 的值。 

#### 19.1.1.1 Object ( [ <var>value</var> ] ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object-value)

当以一个参数 value 或者无参数调用 **Object** 函数，将执行以下步骤：

1.  如果 NewTarget 既不是 **undefined ** 也不是活动函数，则：
    1.  返回 [OrdinaryCreateFromConstructor](http://www.ecma-international.org/ecma-262/7.0/#sec-ordinarycreatefromconstructor)(NewTarget, `"%ObjectPrototype%"`)。
2.  如果 value 为 **null**, **undefined** 或者没有提供， 返回 [ObjectCreate](http://www.ecma-international.org/ecma-262/7.0/#sec-objectcreate)[%ObjectPrototype%](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-object-prototype-object)。
3.  返回 [ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject)。

**Object** 构造函数的 **length** 属性为1。

### 19.1.2 Object 构造函数的属性 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-object-constructor)


Object 构造函数的 [[Prototype]] 内部属性值是内置的 [%FunctionPrototype%](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-function-prototype-object) 对象。

除了 **length** 属性之外，Object 构造函数拥有以下属性：

#### 19.1.2.1 Object.assign ( <var>target</var>, ...<var>sources</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.assign)

**assgin** 函数被用来从一个或者多个源对象拷贝所有可枚举的自身属性到一个目标对象上。当调用 assign 函数时，将执行如下步骤：

1.  令 <var>to</var> 为 [ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject) (<var>target</var>)。
2.  如果只传递了一个参数, 返回 <var>to</var>。
3.  令 <var>sources</var> 为从第二个参数开始组成的一个 [List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type)。
4.  对于按照index升序遍历<var>sources</var>的每个<var>nextSource</var>元素:
    1.  如果 <var>nextSource</var> 为 undefined 或者 null, 令 <var>keys</var> 为一个新的空 [List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type)。
    2.  否则，
        1.  令 <var>from</var> 为[ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject) (<var>nextSource</var>)。
        2.  令 <var>keys</var> 为 <var>from</var>.[[OwnPropertyKeys]]\( \)。
    3.  对于在<var>keys</var> [List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type) 序列中的每个<var>nextKey</var> 元素重复,,
        1.  令 <var>desc</var> 为 <var>from</var>.[[GetOwnProperty]](<var>nextKey</var>)。
        2.  如果 <var>desc</var> 是 undefined 并且 <var>desc</var>.[[Enumerable]] is true, 则
            1.  令 <var>propValue</var> 为[Get](http://www.ecma-international.org/ecma-262/7.0/#sec-get-o-p)(<var>from</var>, <var>nextKey</var>)。
            2.  执行[Set](http://www.ecma-international.org/ecma-262/7.0/#sec-set-o-p-v-throw)(<var>to</var>, <var>nextKey</var>, <var>propValue</var>, true)。
5.  返回 <var>to</var>。

**assign** 方法的 **length** 属性是2。


#### 19.1.2.2 Object.create ( <var>O</var>, <var>Properties</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.create)

**create** 函数创建具有指定原型的新对象，当调用 **create** 函数时，将执行以下步骤：

1.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>O</var>) 既不是对象也不是 Null, 抛 **TypeError** 异常。
2.  令 <var>obj</var> 为 [ObjectCreate](http://www.ecma-international.org/ecma-262/7.0/#sec-objectcreate) (<var>O</var>)。
3.  如果 <var>Properties</var> 不是 undefined, 则
    1.  返回[ObjectDefineProperties](http://www.ecma-international.org/ecma-262/7.0/#sec-objectdefineproperties) (<var>obj</var>, <var>Properties</var>)。
4.  返回 <var>obj</var>。

#### 19.1.2.3 Object.defineProperties ( <var>O</var>, <var>Properties</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.defineproperties)

**defineProperties** 函数用于给一个对象添加一个自身属性 并/或 更新现有自身属性的特性。当调用 **defineProperties** 函数，执行以下步骤：

1.  返回 [ObjectDefineProperties](http://www.ecma-international.org/ecma-262/7.0/#sec-objectdefineproperties)(<var>O</var>, <var>Properties</var>)。

##### 19.1.2.3.1 运行时语义: ObjectDefineProperties ( <var>O</var>, <var>Properties</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-objectdefineproperties)

抽象操作 ObjectDefineProperties 使用 <var>O</var> 和 <var>Properties</var> 参数调用时执行以下步骤：

1.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>O</var>) 不是一个 Object, 抛出 **TypeError** 异常
2.  令 <var>props</var> 为 [ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject) (<var>Properties</var>)。
3.  令 <var>keys</var> 为 <var>props</var>.[[OwnPropertyKeys]]\( \)。
4.  令 <var>descriptors</var> 为一个空[List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type).
5.  按照顺序 对[List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type) keys 中的每个元素 nextKey 重复,
    1.  令 <var>propDesc</var> 为 <var>props</var>.[[GetOwnProperty]](<var>nextKey</var>).
    2.  如果 <var>propDesc</var> 不是 undefined 并且 <var>propDesc</var>.[[Enumerable]] 为 true, 则
        1.  令 <var>descObj</var> 为 [Get](http://www.ecma-international.org/ecma-262/7.0/#sec-get-o-p) (<var>props</var>, <var>nextKey</var>)。
        2.  令 <var>desc</var> 为[ToPropertyDescriptor](http://www.ecma-international.org/ecma-262/7.0/#sec-topropertydescriptor) (<var>descObj</var>).
        3.  将由 <var>nextKey</var> 和 <var>desc</var> 组成的数值对(一对 [List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type) 元素) 插入 <var>descriptors</var> 的尾部。
6.  对于 <var>descriptors</var> 的list顺序中每个 <var>pair</var>,
    1.  令 <var>P</var> 为 <var>pair</var> 的第一个元素。
    2.  令 <var>desc</var> 为 <var>pair</var>的第二个元素。
    3.  执行[DefinePropertyOrThrow](http://www.ecma-international.org/ecma-262/7.0/#sec-definepropertyorthrow) (<var>O</var>, <var>P</var>, <var>desc</var>)。
7.  Return <var>O</var>。

#### 19.1.2.4 Object.defineProperty ( <var>O</var>, <var>P</var>, <var>Attributes</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.defineproperty)

**defineProperty** 函数用于给一个对象添加一个自身属性 并/或 更新现有自身属性的特性。当调用 **defineProperty** 函数，将执行以下步骤：

1.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>O</var>) 不是 Object, 抛出 **TypeError** 异常。
2.  令 <var>key</var> 为 [ToPropertyKey](http://www.ecma-international.org/ecma-262/7.0/#sec-topropertykey) (<var>P</var>)。
3.  令 <var>desc</var> 为 [ToPropertyDescriptor](http://www.ecma-international.org/ecma-262/7.0/#sec-topropertydescriptor)。
4.  执行 [DefinePropertyOrThrow](http://www.ecma-international.org/ecma-262/7.0/#sec-definepropertyorthrow) (<var>O</var>, <var>key</var>, <var>desc</var>)。
5.  返回 <var>O</var>。


#### 19.1.2.5 Object.freeze ( <var>O</var> )[#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.freeze)

当调用 **freeze** 函数时，将执行以下步骤：

1.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) 不是 Object, 返回 <var>O</var>。
2.  令 <var>status</var> [SetIntegrityLevel](http://www.ecma-international.org/ecma-262/7.0/#sec-setintegritylevel) (<var>O</var>, **"frozen"**)。
3.  如果 <var>status</var> 为 **false**, 抛出 **TypeError** 异常。
4.  返回 <var>O</var>。


#### 19.1.2.6 Object.getOwnPropertyDescriptor ( <var>O</var>, <var>P</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.getownpropertydescriptor)

当调用 **getOwnPropertyDescriptor** 函数时，将执行以下步骤：

1.  令 <var>obj</var> 为 [ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject) (<var>O</var>)。
2.  令 <var>key</var> 为[ToPropertyKey](http://www.ecma-international.org/ecma-262/7.0/#sec-topropertykey) (<var>P</var>)。
3.  令 <var>desc</var> 为 <var>obj</var>.[[GetOwnProperty]](<var>key</var>)。
4.  返回 [FromPropertyDescriptor](http://www.ecma-international.org/ecma-262/7.0/#sec-frompropertydescriptor)(<var>desc</var>)。


#### 19.1.2.7 Object.getOwnPropertyNames ( <var>O</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.getownpropertynames)

当调用 **getOwnPropertyNames** 函数时，将执行以下步骤：

1.  返回 [GetOwnPropertyKeys](http://www.ecma-international.org/ecma-262/7.0/#sec-getownpropertykeys) (<var>O</var>, String)。


#### 19.1.2.8 Object.getOwnPropertySymbols ( <var>O</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.getownpropertysymbols)

当调用 **getOwnPropertySymbols** 函数时，将执行以下步骤：

1.  返回 [GetOwnPropertyKeys](http://www.ecma-international.org/ecma-262/7.0/#sec-getownpropertykeys) (<var>O</var>, Symbol)。


##### 19.1.2.8.1 运行时语义: GetOwnPropertyKeys ( <var>O</var>, <var>Type</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-getownpropertykeys)


当以参数 O 和 Type，调用抽象操作GetOwnPropertyKeys时，其中 O 是一个 Object 而 Type为ECMAScript 中的一种特定类型的字符串形式或者 Symbol。将执行以下步骤：

1.  令 <var>obj</var> 为 [ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject) (<var>O</var>)。
2.  令 <var>keys</var> 为 <var>obj</var>.[[OwnPropertyKeys]]\( \)。
3.  令 <var>nameList</var> 为一个空 [List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type)。
4.  按照顺序 对[List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type) keys 中的每个元素 nextKey 重复
    1.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>nextKey</var>) 是 <var>Type</var>,则
        1.  把 <var>nextKey</var> 作为最后一个元素附加到 <var>nameList</var>。
5.  返回 [CreateArrayFromList](http://www.ecma-international.org/ecma-262/7.0/#sec-createarrayfromlist) (<var>nameList</var>)。


#### 19.1.2.9 Object.getPrototypeOf ( <var>O</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.getprototypeof)

当以参数 O 调用 **getPrototypeOf** 函数时，将执行以下步骤：

1.  令 <var>obj</var> 为 [ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject) (<var>O</var>).
2.  返回 <var>obj</var>.[[GetPrototypeOf]]\(  \)。


#### 19.1.2.10 Object.is ( <var>value1</var>, <var>value2</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.is)

当以参数 value1 和 value2 调用 is 函数时，将执行以下步骤：

1.  返回 [SameValue](http://www.ecma-international.org/ecma-262/7.0/#sec-samevalue) (<var>value1</var>, <var>value2</var>)。

#### 19.1.2.11 Object.isExtensible ( <var>O</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.isextensible)
当以参数 O 调用 isExtensible 函数时，将执行以下步骤：

1.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>O</var>) 不是 Object, 返回 **false**。
2.  返回 [IsExtensible](http://www.ecma-international.org/ecma-262/7.0/#sec-isextensible-o)(<var>O</var>)。

#### 19.1.2.12 Object.isFrozen ( <var>O</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.isfrozen)

当以参数 O 调用 isFrozen 函数时，将执行以下步骤：

1.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>O</var>) 不是 Object, 返回 **true**。
2.  返回 [TestIntegrityLevel](http://www.ecma-international.org/ecma-262/7.0/#sec-testintegritylevel) (<var>O</var>, **"frozen"**)。

#### 19.1.2.13 Object.isSealed ( <var>O</var> )[#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.issealed)

当使用参数 <var>O</var> 调用 isSealed 函数时，将执行以下步骤：

1.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>O</var>) 不是 Object, 返回 **true**。
2.  返回 [TestIntegrityLevel](http://www.ecma-international.org/ecma-262/7.0/#sec-testintegritylevel) (<var>O</var>, **"sealed"**)。

#### 19.1.2.14 Object.keys ( <var>O</var> )[#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.keys)

当以参数 O 调用 keys 函数，将执行以下步骤：

1.  令 <var>obj</var> [ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject) (<var>O</var>)。
2.  令 <var>nameList</var> 为 [EnumerableOwnNames](http://www.ecma-international.org/ecma-262/7.0/#sec-enumerableownnames) (<var>obj</var>)。
3.  返回 [CreateArrayFromList](http://www.ecma-international.org/ecma-262/7.0/#sec-createarrayfromlist) (<var>nameList</var>)。

如果一个实现为 for-in 语句的定义了特定的枚举顺序，那么在这个算法的第 3 步中的必须使用相同的枚举顺序。

#### 19.1.2.15 Object.preventExtensions ( <var>O</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.preventextensions)

当调用 **preventExtensions** 函数时，将执行以下步骤：

1.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>O</var>) 不是 Object, 返回 <var>O</var>。
2.  令 <var>status</var> 为 <var>O</var>.[[PreventExtensions]\( \)。
3.  如果 <var>status</var> 是 false, 抛出 **TypeError** 异常。
4.  返回 <var>O</var>。


#### 19.1.2.16 Object.prototype [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.prototype)

**Object.prototype** 的初始值是内置对象 [%ObjectPrototype%](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-object-prototype-object)。
这个属性包含特性 {[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }


#### 19.1.2.17 Object.seal ( <var>O</var> )[#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.seal)

当调用 seal 函数时，将执行以下步骤：

1.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>O</var>) 不是 Object, 返回 <var>O</var>。
2.  令 <var>status</var> 为 [SetIntegrityLevel](http://www.ecma-international.org/ecma-262/7.0/#sec-setintegritylevel) (<var>O</var>, **"sealed"**).
3.  如果 <var>status</var> 为 **false**, 抛出 **TypeError** 异常。
4.  返回 <var>O</var>。


#### 19.1.2.18 Object.setPrototypeOf ( <var>O</var>, <var>proto</var> )[#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.setprototypeof)

当使用<var>O</var> 和 proto 参数调用 **setPrototypeOf** 函数时，将执行以下步骤：

1.  令 <var>O</var> 为 [RequireObjectCoercible](http://www.ecma-international.org/ecma-262/7.0/#sec-requireobjectcoercible) (<var>O</var>)。
2.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>proto</var>) 既不是 Object 也不是 Null，抛出 **TypeError** 异常。
3.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>O</var>) 不是 Object, 返回 <var>O</var>。
4.  令 <var>status</var> 为 <var>O</var>.[[SetPrototypeOf]](<var>proto</var>).
5.  如果 <var>status</var> 是 **false**, 抛出 **TypeError** 异常。
6.  返回 <var>O</var>。

### 19.1.3 Object 的 prototype 对象的属性 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-object-prototype-object)

Object 的 prototype 对象是 %ObjectPrototype% 内置对象。Object 的 prototype 对象是一个 [不可变原型特殊对象](http://www.ecma-international.org/ecma-262/7.0/#sec-immutable-prototype-exotic-objects)。

 Object 的 prototype 对象的 [[Prototype]] 内部属性的值是 **null**，[[Extensible]] 内部属性的初始值是 true。

#### 19.1.3.1 Object.prototype.constructor [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.prototype.constructor)

Object.prototype.constructor 的初始值是 [%Object%](http://www.ecma-international.org/ecma-262/7.0/#sec-object-constructor) 内置对象。

#### 19.1.3.2 Object.prototype.hasOwnProperty ( <var>V</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.prototype.hasownproperty)

当以参数 <var>V</var> 调用 hasOwnProperty 方法时，将执行以下步骤：

1.  令 <var>P</var> 为 [ToPropertyKey](http://www.ecma-international.org/ecma-262/7.0/#sec-topropertykey) (<var>V</var>)。
2.  令 <var>O</var> 为 [ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject) (**this值**).
3.  返回 [HasOwnProperty](http://www.ecma-international.org/ecma-262/7.0/#sec-hasownproperty) (<var>O</var>, <var>P</var>)。

注意：步骤 1 和 2 的选择这样的顺序是为了确保在本规范之前的版本中，如在步骤 1 里抛出的任何异常，即使在 **this值** 是 **undefined** 或 **null** 的情况下这些异常也会继续抛出。

#### 19.1.3.3 Object.prototype.isPrototypeOf ( <var>V</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.prototype.isprototypeof)

当以参数 <var>V</var> 调用 **isPrototypeOf** 方法 将执行以下步骤：

1.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>V</var>) 不是 Object, 返回 **false**。
2.  令 <var>O</var> 为 [ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject) (**this的值**)。
3.  重复
    1.  令 <var>V</var> 为 <var>V</var>.[[GetPrototypeOf]]( )。
    2.  如果 <var>V</var> 为 **null**, 返回 **false**。
    3.  如果 [SameValue](http://www.ecma-international.org/ecma-262/7.0/#sec-samevalue)(<var>O</var>, <var>V</var>) 为 **true**, 返回 **true**。

注意：步骤1和2的排序保证了本规范的先前版本，在<var>V</ var>不是对象并且 **this** 为 **undefined** 或为 **null** 的情况下执行之前相同的操作。


#### 19.1.3.4 Object.prototype.propertyIsEnumerable ( <var>V</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.prototype.propertyisenumerable)

当以参数 <var>V</var> 调用 propertyIsEnumerable 方法 将执行以下步骤：

1.  令 <var>P</var> 为 [ToPropertyKey](http://www.ecma-international.org/ecma-262/7.0/#sec-topropertykey) (<var>V</var>)。
2.  令 <var>O</var> 为 [ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject) (**this 值**)。
3.  令 <var>desc</var> 为 <var>O</var>.[[GetOwnProperty]](<var>P</var>)。
4.  如果 <var>desc</var> 为 **undefined**, 返回 **false**。
5.  返回 <var>desc</var>.[[Enumerable]] 的值。

注意1： 这个方法不考虑原型链中的对象。

注意2：步骤 1 和 2 的选择这样的顺序是为了确保在本规范之前的版本中，如在步骤 1 里抛出的任何异常，即使在 **this**  是 **undefined** 或 **null** 的情况下这些异常也会继续抛出。

#### 19.1.3.5 Object.prototype.toLocaleString ( [ <var>reserved1</var> [ , <var>reserved2</var> ] ] ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.prototype.tolocalestring)

当 **toLocaleString** 方法被调用时，将执行以下步骤：

1.  令 <var>O</var> 为 this。
2.  返回 [Invoke](http://www.ecma-international.org/ecma-262/7.0/#sec-invoke) (<var>O</var>, **"toString"**)。

此函数的可选参数未使用，但旨在对应于ECMA-402 toLocalString 函数使用的参数模式。 不包括ECMA-402支持的实现不得将这些参数位置用于其他目的。

注意1：此函数为在特定于语言环境下没有toString行为的对象提供了一个通用的 **toLocaleString** 实现。 **Array**, **Number**, **Date** 提供了它们自身的语言环境敏感的 **toLocaleString** 方法。

注意2：ECMA-402故意不提供此默认实现的替代方法。

#### 19.1.3.6 Object.prototype.toString ( ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)

当 **toString** 方法被调用，将执行以下步骤：

1.  如果 **this** 为 **undefined**, 返回 **"[object Undefined]"**。
2.  如果 **this** 为 **null**, 返回 **"[object Null]"**。
3.  令 <var>O</var> 为 [ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject) (this 的值)。
4.  令 <var>isArray</var> 为 [IsArray](http://www.ecma-international.org/ecma-262/7.0/#sec-isarray) (<var>O</var>)。
5.  如果 <var>isArray</var> 为 true, 令 <var>builtinTag</var> 为 "Array"。
6.  否则, 如果 <var>O</var> is an 特殊的字符串对象, let <var>builtinTag</var> 为 "String"。
7.  否则, 如果 <var>O</var> 有 [[ParameterMap]] 内部属性值, 令 <var>builtinTag</var> 为 "Arguments"。
8.  否则, 如果 <var>O</var> 有内置 [[Call]] 方法, 令 <var>builtinTag</var> 为 "Function"。
9.  否则, 如果 <var>O</var> 有 [[ErrorData]] 内部属性值, 令 <var>builtinTag</var> 为 "Error"。
10.  否则, 如果 <var>O</var> 有 [[BooleanData]] 内部属性值, 令 <var>builtinTag</var> 为 "Boolean"。
11.  否则, 如果 <var>O</var> 有 [[NumberData]] 内部属性值, 令 <var>builtinTag</var> 为 "Number"。
12.  否则, 如果 <var>O</var> 有 [[DateValue]] 内部属性值, 令 <var>builtinTag</var> 为 "Date"。
13.  否则, 如果 <var>O</var> 有 [[RegExpMatcher]] 内部属性值, 令 <var>builtinTag</var> 为 "RegExp"。
14.  否则, 令 <var>builtinTag</var> 为 `"Object"`.
15.  令 <var>tag</var> 为 [Get](http://www.ecma-international.org/ecma-262/7.0/#sec-get-o-p) (<var>O</var>, @@toStringTag).
16.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>tag</var>) 不是字符串, 令 <var>tag</var> 为 <var>builtinTag</var>。
17.  返回三个字符串 "[object ", class, and "]" 连起来的字符串。

这个方法是 %ObjProto_toString% 内部对象。

注意：曾经，此函数偶尔用于访问在本规范的先前版本中[[Class]]内部属性值的String值，作为各种内置对象的标称类型标签。 上面的 toString 定义保留了传统代码使用 toString 测试那些特定种类的内置对象类型的的兼容性。 它不为其他类型的内置对象或程序定义的对象提供可靠的类型检测机制。 此外，程序可以使用 @@toStringTag以验证此类传统类型测试的可靠性。

#### 19.1.3.7 Object.prototype.valueOf ( ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-object.prototype.valueof)

当调用 valueOf 方法时，将执行以下步骤：

1.  返回 [ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject) (this value)。

这个函数是 %ObjProto_valueOf% 内置对象。



### 19.1.4 Object 实例属性 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-object-instances)

对象实例除了继承自Object原型对象之外没有特殊的属性。


## 19.2 Function 对象 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function-objects)



### 19.2.1 Function 构造函数 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function-constructor)


Function 构造函数是 %Function% 内置对象，是 [全局对象](http://www.ecma-international.org/ecma-262/7.0/#global-object) Function 属性的值。当Function作为一个函数而不是一个构造函数被调用时，它创建并初始化一个新的Function对象。因此，Function（...）函数调用等效于具有相同参数的对象创建表达式new Function（...）。


Function 构造函数设计为可子类化，它可以用作类定义的 extends 子句的值。打算继承指定的 Function 行为的子类构造函数必须包含一个 super 调用 Function 构造函数来创建和初始化一个具有内部函数行为所需的内部属性的子类实例。

All ECMAScript syntactic forms for defining function objects create instances of `Function`. There is no syntactic means to create instances of `Function` subclasses except for the built-in Generator Function subclass.

用于定义函数对象的所有 ECMAScript 语法形式都创建了 Function 的实例。 除了内置的 Generator Function 子类之外，没有用来创建 Function 子类的实例的语法方法。



#### 19.2.1.1 Function ( <var>p1</var>, <var>p2</var>, … , <var>pn</var>, <var>body</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function-p1-p2-pn-body)


最后一个参数指定函数的主体（可执行代码） 任何前面的参数指定形式参数。当使用 p1, p2, ..., pn, body（n 可能为0，也就是没有p参数，body 参数也可能没有提供）调用 Function 函数，将执行以下步骤：

1.  令 <var>C</var> 为 [活动函数对象](http://www.ecma-international.org/ecma-262/7.0/#active-function-object)。
2.  令 <var>args</var> 为由[[Call]]或[[Construct]]传递给此函数的<var>argumentsList</var>。
3.  返回 [CreateDynamicFunction](http://www.ecma-international.org/ecma-262/7.0/#sec-createdynamicfunction) (<var>C</var>, NewTarget, `"normal"`, <var>args</var>).

注意：
为每个形参指定一个参数是允许的，但没必要。例如以下三个表达式产生相同的结果:

```
 new Function("a", "b", "c", "return a+b+c")
 new Function("a, b, c", "return a+b+c")
 new Function("a,b", "c", "return a+b+c")
```


##### 19.2.1.1.1 运行时语义: CreateDynamicFunction(<var>constructor</var>, <var>newTarget</var>, <var>kind</var>, <var>args</var>) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-createdynamicfunction)

使用参数 construtor, newTarget, kind 和 args 调用抽象操作 CreateDynamicFunction。
constructor 是执行此操作的构造函数， newTarget 是 new 语句最初应用的构造函数, kind 是 "normal" 或者 "generator", args 是包含传递给 constructor 的实际参数值的[List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type)。 将采用以下步骤:


1.  如果 newTarget 是 undefined, 令 newTarget 为 constructor。
2.  如果 kind 是 "normal", 则
    1.  令 <var>goal</var> 为语法符号[FunctionBody](http://www.ecma-international.org/ecma-262/7.0/#prod-FunctionBody)。
    2.  令 <var>parameterGoal</var> 为语法符号 [FormalParameters](http://www.ecma-international.org/ecma-262/7.0/#prod-FormalParameters)。
    3.  令 <var>fallbackProto</var> 为 `"%FunctionPrototype%"`。
3.  否则,
    1.  令 <var>goal</var> 为语法符号 [GeneratorBody](http://www.ecma-international.org/ecma-262/7.0/#prod-GeneratorBody)。
    2.  令 <var>parameterGoal</var> 为语法符号[FormalParameters](http://www.ecma-international.org/ecma-262/7.0/#prod-FormalParameters)[Yield]。
    3.  令 <var>fallbackProto</var> 为 `"%Generator%"`。
4.  令 <var>argCount</var> 为 <var>args</var> 中的元素个数。
5.  令 <var>P</var> 为空字符串。
6.  如果 <var>argCount</var> = 0, 令 <var>bodyText</var> 为空字符串。
7.  否则，如果 <var>argCount</var> = 1, 令 <var>bodyText</var> 为 <var>args</var>[0]。
8.  否则，如果 <var>argCount</var> > 1,
    1.  令 <var>firstArg</var> 为 <var>args</var>[0]。
    2.  令 <var>P</var> 为 [ToString](http://www.ecma-international.org/ecma-262/7.0/#sec-tostring) (<var>firstArg</var>)。
    3.  令 <var>k</var> 为 1。
    4.  重复, 直到 <var>k</var> < <var>argCount</var>-1
        1.  令 <var>nextArg</var> 为 <var>args</var>[<var>k</var>]。
        2.  令 <var>nextArgString</var> 为 [ToString](http://www.ecma-international.org/ecma-262/7.0/#sec-tostring) (<var>nextArg</var>)。
        3.  令 P为连接 <var>P</var>的前一个值, "," (逗号), 和 <var>nextArgString</var> 的结果。
        4.  将 <var>k</var> 增加 1。
    5.  令 <var>bodyText</var> 为 <var>args</var>[<var>k</var>].
9.  令 <var>bodyText</var> 为 [ToString](http://www.ecma-international.org/ecma-262/7.0/#sec-tostring) (<var>bodyText</var>)。
10.  令 <var>parameters</var> 为解析 <var>P</var> 的结果, 解释为UTF-16编码的Unicode 文本，如[6.1.4](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types-string-type) 所述 , 使用 <var>parameterGoal</var> 作为目标符号。如果解析失败则抛出SyntaxError异常。
11.  令 <var>body</var> 为解析 <var>bodyText</var> 的结果, 解释为UTF-16编码的Unicode 文本，如[6.1.4](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types-string-type) 所述 , 使用 <var>parameterGoal</var> 作为目标符号。如果解析失败则抛出SyntaxError异常。
12.  如果 <var>bodyText</var> 是 [严格模式代码](http://www.ecma-international.org/ecma-262/7.0/#sec-strict-mode-code) , 则 let <var>strict</var> 为 true, 否则 let <var>strict</var> 为 false。
13.  如果对<var>parameters</var> 或者 <var>body</var> 检测到任何静态语义错误, 则根据错误的类型抛出一个SyntaxError或ReferenceError异常。 如果 <var>strict</var> 为 true, 则应用 [StrictFormalParameters](http://www.ecma-international.org/ecma-262/7.0/#prod-StrictFormalParameters):[FormalParameters](http://www.ecma-international.org/ecma-262/7.0/#prod-FormalParameters) 的Early Error规则。解析 和 [early error](http://www.ecma-international.org/ecma-262/7.0/#early-error) 检测可以以实现相关的方式交织。
14. 如果 <var>body</var> 的 ContainsUseStrict 为 true ，并且<var>parameters</var> 的 IsSimpleParameterList 为 false, 抛出 SyntaxError 异常。
15.  如果 parameters 的 BoundNames的任何元素同时出现在 body 的LexicallyDeclaredNames中, 抛出 SyntaxError 异常。
16.  如果 <var>body</var> 包含 [SuperCall](http://www.ecma-international.org/ecma-262/7.0/#prod-SuperCall)为 true, 抛出 SyntaxError 异常。
17.  如果 <var>parameters</var> 包含[SuperCall](http://www.ecma-international.org/ecma-262/7.0/#prod-SuperCall)为 true, 抛出 SyntaxError 异常。
18.  如果 <var>body</var> 包含[SuperProperty](http://www.ecma-international.org/ecma-262/7.0/#prod-SuperProperty)为 true, 抛出 SyntaxError 异常。
19.  如果 <var>parameters</var> 包含[SuperProperty](http://www.ecma-international.org/ecma-262/7.0/#prod-SuperProperty) 为 true, 抛出 SyntaxError 异常。
20.  如果 <var>kind</var> 是 "generator", 那么
    1.  如果 <var>parameters</var> 包含 [YieldExpression](http://www.ecma-international.org/ecma-262/7.0/#prod-YieldExpression) 为 true, 抛出 SyntaxError 异常。
21.  如果 <var>strict</var> 是 true, 那么
    1.  如果 <var>parameters</var> 的 BoundNames 包含任何重复的元素, 抛出 SyntaxError 异常。
22.  令 <var>proto</var> 为 [GetPrototypeFromConstructor](http://www.ecma-international.org/ecma-262/7.0/#sec-getprototypefromconstructor) (<var>newTarget</var>, <var>fallbackProto</var>)。
23.  令 <var>F</var> 为 [FunctionAllocate](http://www.ecma-international.org/ecma-262/7.0/#sec-functionallocate) (<var>proto</var>, <var>strict</var>, <var>kind</var>)。
24.  令 <var>realmF</var> 为 <var>F</var> 的[[Realm]] 内置属性的值.
25.  令 <var>scope</var> 为 <var>realmF</var>.[[GlobalEnv]]。
26.  执行 [FunctionInitialize](http://www.ecma-international.org/ecma-262/7.0/#sec-functioninitialize) (<var>F</var>, <emu-const>Normal</emu-const>, <var>parameters</var>, <var>body</var>, <var>scope</var>)。
27.  如果 <var>kind</var> 是 "generator", 那么
    1.  令 <var>prototype</var> 为 [ObjectCreate](http://www.ecma-international.org/ecma-262/7.0/#sec-objectcreate) ([%GeneratorPrototype%](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-generator-prototype) )。
    2.  执行 [DefinePropertyOrThrow](http://www.ecma-international.org/ecma-262/7.0/#sec-definepropertyorthrow) (<var>F</var>, `"prototype"`, PropertyDescriptor{[[Value]]: <var>prototype</var>, [[Writable]]: true, [[Enumerable]]:false, [[Configurable]]: false})。
28.  否则, 执行 [MakeConstructor](http://www.ecma-international.org/ecma-262/7.0/#sec-makeconstructor) (<var>F</var>)。
29.  执行 [SetFunctionName](http://www.ecma-international.org/ecma-262/7.0/#sec-setfunctionname) (<var>F</var>, `"anonymous"`)。
30.  返回 <var>F</var>。

注意：
对于使用 CreateDynamicFunction 创建的每个函数，都会自动创建一个“prototype”属性，以提供该函数将用作构造函数的可能性。

### 19.2.2 Function 构造函数的属性 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-function-constructor)

Function构造函数本身是一个内置的函数对象。Function构造函数的 [[Prototype]] 内部属性的值是 ％Function Prototype％ 内在对象。
Function 构造函数的 [[Extensible]] 内置属性值是 true。
Function 构造函数拥有以下属性：

#### 19.2.2.1 Function.length [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function.length)

这是一个值为1的数据属性。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。



#### 19.2.2.2 Function.prototype [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype)

Function.prototype 的值是 [%FunctionPrototype%](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-function-prototype-object) , 内置的 Function 原型对象。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.



### 19.2.3 Properties of the Function Prototype Object [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-function-prototype-object)

函数原型对象是内在对象％FunctionPrototype％。 函数原型对象本身是一个内置的函数对象。 当被调用时，它接受任何参数并返回undefined。 它没有一个[[Construct]]内部方法，因此它不是一个构造函数。

注意

函数原型对象被指定为函数对象，以确保与在ECMAScript 2015规范之前创建的ECMAScript代码兼容。

Function原型对象的[[Prototype]]内部属性值是内在对象 ％ObjectPrototype％ 。 Function原型对象的[[Extensible]]内部属性值的初始值为true。
函数原型对象没有原型属性。
Function原型对象的length属性的值为0。
Function原型对象的name属性的值是空的String。


#### 19.2.3.1 Function.prototype.apply ( <var>thisArg</var>, <var>argArray</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply)
当对具有参数thisArg和argArray的对象func调用apply方法时，将执行以下步骤：

1.  如果 [IsCallable](http://www.ecma-international.org/ecma-262/7.0/#sec-iscallable) (<var>func</var>) 为 false, 抛出一个 TypeError 异常。
2.  如果 <var>argArray</var> 为 null 或者 undefined, 则
    1.  执行 [PrepareForTailCall](http://www.ecma-international.org/ecma-262/7.0/#sec-preparefortailcall) ()。
    2.  返回 [Call](http://www.ecma-international.org/ecma-262/7.0/#sec-call) (<var>func</var>, <var>thisArg</var>)。
3.  令 <var>argList</var> be [CreateListFromArrayLike](http://www.ecma-international.org/ecma-262/7.0/#sec-createlistfromarraylike) (<var>argArray</var>)。
4.  执行 [PrepareForTailCall](http://www.ecma-international.org/ecma-262/7.0/#sec-preparefortailcall) ().
5.  返回  [Call](http://www.ecma-international.org/ecma-262/7.0/#sec-call) (<var>func</var>, <var>thisArg</var>, <var>argList</var>)。

注意1：
thisArg 作为 this 值在传递时不被修改。为 undefined 或者 null 的 thisArg 被替换为 [全局对象](http://www.ecma-international.org/ecma-262/7.0/#global-object)  而 其他所有值将被执行 [ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject)并将结果作为 this 值，这是第三版引入的变化。 即使 thisArg 未经修改地传递，非严格函数在进入函数时仍然执行这些转换。

注意2：
如果 <var>func</var> 是一个箭头函数或者[bound函数](http://www.ecma-international.org/ecma-262/7.0/#sec-bound-function-exotic-objects) ，那么thisArg在步骤5中将被[[Call]]函数忽略。



#### 19.2.3.2 Function.prototype.bind ( <var>thisArg</var>, ...<var>args</var>) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.bind)


当一参数 thisArg 和 0 个 或者 多个 args 参数调用 bind 函数时， 执行以下步骤：

1.  令 <var>Target</var> 为 this 值。
2.  如果 [IsCallable](http://www.ecma-international.org/ecma-262/7.0/#sec-iscallable) (<var>Target</var>) 是 false, 抛出一个 TypeError 异常。
3.  令 <var>args</var> 为一个新[List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type)（可能为空），它包含按顺序的 thisArg 后面的所有参数。
4.  令 <var>F</var> 为 [BoundFunctionCreate](http://www.ecma-international.org/ecma-262/7.0/#sec-boundfunctioncreate) (<var>Target</var>, <var>thisArg</var>, <var>args</var>)。
5.  令 <var>targetHasLength</var> 为 [HasOwnProperty](http://www.ecma-international.org/ecma-262/7.0/#sec-hasownproperty) (<var>Target</var>, `"length"`)。
6.  如果 <var>targetHasLength</var> 是 true, 则
    1.  令 <var>targetLen</var> 为 [Get](http://www.ecma-international.org/ecma-262/7.0/#sec-get-o-p) (<var>Target</var>, `"length"`)。
    2.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>targetLen</var>) 不是 Number, 令 <var>L</var> 为 0。
    3.  否则,
        1.  令 <var>targetLen</var> 为 [ToInteger](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger) (<var>targetLen</var>)。
        2.  令 <var>L</var> 为 0 与 targetLen 减去 args 元素个数的结果中较大的数。
7.  否则 令 <var>L</var> 为 0。
8.  执行 ! [DefinePropertyOrThrow](http://www.ecma-international.org/ecma-262/7.0/#sec-definepropertyorthrow) (<var>F</var>, `"length"`, PropertyDescriptor {[[Value]]: <var>L</var>, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true})。
9.  令 <var>targetName</var> 为 [Get](http://www.ecma-international.org/ecma-262/7.0/#sec-get-o-p) (<var>Target</var>, `"name"`).
10.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>targetName</var>) 不是 String, 令 <var>targetName</var> 为空字符串。
11.  执行 [SetFunctionName](http://www.ecma-international.org/ecma-262/7.0/#sec-setfunctionname) (<var>F</var>, <var>targetName</var>, `"bound"`)。
12.  返回 <var>F</var>。

注意1：
使用 Function.prototype.bind 创建的函数对象是异常对象。 他们也没有一个“原型”属性。

注意2：
如果 <var>Target</var> 是一个箭头函数或者[bound函数](http://www.ecma-international.org/ecma-262/7.0/#sec-bound-function-exotic-objects)那么传递给这个方法的 thisArg 将不会后续的调用 F 使用。


#### 19.2.3.3 Function.prototype.call (<var>thisArg</var>, ...<var>args</var>) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.call)

当以 thisArg 和可选的 arg1, arg2 等等作为参数在一个 func 对象上调用 call 方法，采用如下步骤：

1.  如果 [IsCallable](http://www.ecma-international.org/ecma-262/7.0/#sec-iscallable) (func) 是 false, 则抛出 TypeError 异常。
2.  令 <var>argList</var> 为一个空 [List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type)。
3.  如果如果调用这个方法的参数多余一个, 则从第二个参数开始以从左到右的顺序,将每个参数插入为 argList 的最后一个元素。
4.  执行 [PrepareForTailCall](http://www.ecma-international.org/ecma-262/7.0/#sec-preparefortailcall) ().
5.  返回[Call](http://www.ecma-international.org/ecma-262/7.0/#sec-call) (<var>func</var>, <var>thisArg</var>, <var>argList</var>)。

注意1：
thisArg 作为 this 值在传递时不被修改。为 undefined 或者 null 的 thisArg 被替换为 [全局对象](http://www.ecma-international.org/ecma-262/7.0/#global-object)  而 其他所有值将被执行 [ToObject](http://www.ecma-international.org/ecma-262/7.0/#sec-toobject)并将结果作为 this 值，这是第三版引入的变化。 即使 thisArg 未经修改地传递，非严格函数在进入函数时仍然执行这些转换。

注意2：
如果 <var>func</var> 是一个箭头函数或者一个 [bound function](http://www.ecma-international.org/ecma-262/7.0/#sec-bound-function-exotic-objects) 则在步骤5中<var>thisArg</var>将被[[call]]函数忽略。



#### 19.2.3.4 Function.prototype.constructor [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.constructor)


Function.prototype.constructor 的初始值是 [%Function%](http://www.ecma-international.org/ecma-262/7.0/#sec-function-constructor) 内在对象。


#### 19.2.3.5 Function.prototype.toString ( ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.tostring)


当使用 func 对象调用 toString 函数时，采用以下步骤：


1.  如果 <var>func</var> 是一个 Bound Function 异常对, 那么
    1.  返回func的依赖于实现的String源代码表示。 表示必须符合以下规则。它取决于实现是否包括[bound function](http://www.ecma-international.org/ecma-262/7.0/#sec-bound-function-exotic-objects)信息或关于目标函数的信息。
2.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>func</var>) 是 Object 并且是内置函数对象或者有[[ECMAScriptCode]] 内部属性值, 则
    1.  返回func的依赖于实现的String源代码表示。 表示必须符合以下规则。
3.  抛出 TypeError 异常。

toString 表示要求:

*   根据对象的实际特性，字符串表示必须具有[FunctionDeclaration](http://www.ecma-international.org/ecma-262/7.0/#prod-FunctionDeclaration), [FunctionExpression](http://www.ecma-international.org/ecma-262/7.0/#prod-FunctionExpression), [GeneratorDeclaration](http://www.ecma-international.org/ecma-262/7.0/#prod-GeneratorDeclaration),[GeneratorExpression](http://www.ecma-international.org/ecma-262/7.0/#prod-GeneratorExpression), [ClassDeclaration](http://www.ecma-international.org/ecma-262/7.0/#prod-ClassDeclaration), [ClassExpression](http://www.ecma-international.org/ecma-262/7.0/#prod-ClassExpression), [ArrowFunction](http://www.ecma-international.org/ecma-262/7.0/#prod-ArrowFunction), [MethodDefinition](http://www.ecma-international.org/ecma-262/7.0/#prod-MethodDefinition), 或者 [GeneratorMethod](http://www.ecma-international.org/ecma-262/7.0/#prod-GeneratorMethod) 的语法。
*   在表示String中使用和放置空格，行终止符和分号是与实现相关的。
*   如果对象是使用ECMAScript代码定义的，并且返回的字符串表示形式不是 [MethodDefinition](http://www.ecma-international.org/ecma-262/7.0/#prod-MethodDefinition)或[GeneratorMethod](http://www.ecma-international.org/ecma-262/7.0/#prod-GeneratorMethod)的形式，那么表达式必须是这样的：如果字符串被求值，在一个词汇上下文中使用eval，它等同于使用的词汇上下文 创建原始对象，它将导致一个新的功能等同的对象。在这种情况下，返回的源代码不能随意提及原函数的源代码没有自由提及的任何变量，即使这些“额外”名称最初在范围内。
*  如果实现不能产生满足这些条件的源代码字符串，那么它必须返回一个字符串，eval将抛出一个SyntaxError异常。


#### 19.2.3.6 Function.prototype [ @@hasInstance ]( <var>V</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype-@@hasinstance)


当一个对象 F 的 @@hasInstance 放法以参数 V 调用时，将执行以下步骤：

1.  令 <var>F</var> 为  this 值。
2.  返回 [OrdinaryHasInstance](http://www.ecma-international.org/ecma-262/7.0/#sec-ordinaryhasinstance) (<var>F</var>, <var>V</var>)。

这个函数的 name 属性 是"[Symbol.hasInstance]"。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

注意

这是大多数函数继承的@@ hasInstance的默认实现。 @@ hasInstance由instanceof运算符调用以确定值是否是特定构造函数的实例。 表达式如：

```
 `v instanceof F`
```

计算为

```
 `F[@@hasInstance](v)`
```

构造函数可以通过在函数上暴露一个不同的@@ hasInstance`方法来控制哪些对象被`instanceof`识别为它的实例。

该属性是不可写的，不可配置的，以防止篡改，可以用于全局暴露[bound函数]的目标函数。


### 19.2.4 函数实例 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function-instances)


每个函数实例都是ECMAScript函数对象，并具有[表27](http://www.ecma-international.org/ecma-262/7.0/#table-27)中列出的内部属性值。使用Function.prototype.bind方法（[19.2.3.2](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.bind)）创建的函数实例具有[表28](http://www.ecma-international.org/ecma-262/7.0/#table-28)中列出的内部属性值。
函数实例具有以下属性：

#### 19.2.4.1 length [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function-instances-length)


 length 属性值是个整数，表示函数期望的参数的典型数量。然而，语言允许用其他数量的参数来调用函数。当以与函数的 length 属性指定的数量不同的参数个数调用函数时，它的行为依赖于函数自身。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。

#### 19.2.4.2 name [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function-instances-name)

name属性的值是描述函数的String。该名称没有语义意义，但通常是一个变量或属性名称，用于在ECMAScript代码中的定义点处引用该函数。 此属性具有属性{[[Writable]]：false，[[Enumerable]]：false，[[Configurable]]：true}。

根据本规范没有与之关联的上下文名称的匿名函数对象没有自己的name属性，但是继承了 [％FunctionPrototype％](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-function-prototype-object)的name属性。


#### 19.2.4.3 prototype [#](http://www.ecma-international.org/ecma-262/7.0/#sec-function-instances-prototype)


可以用作构造函数的函数实例具有原型属性。每当创建这样的函数实例时，还创建另一个普通对象，它是函数 prototype 属性的初始值。除非另有说明，当该函数作为构造函数调用时，prototype 属性的值用于初始化创建的对象的[[Prototype]]内部属性值。


此属性具有特性{[[Writable]]：true，[[Enumerable]]：false，[[Configurable]]：false}。

注意

使用 Function.prototype.bind 创建的函数对象, 或者通过执行 [MethodDefinition](http://www.ecma-international.org/ecma-262/7.0/#prod-MethodDefinition) (不是 [GeneratorMethod](http://www.ecma-international.org/ecma-262/7.0/#prod-GeneratorMethod) 或者 [ArrowFunction](http://www.ecma-international.org/ecma-262/7.0/#prod-ArrowFunction) 语法生成 没有 prototype 属性。


## 19.3 Boolean 对象 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-boolean-objects)



### 19.3.1 Boolean 构造函数 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-boolean-constructor)


Boolean 构造函数是内置 %Boolean% 对象， 是 [全局对象](http://www.ecma-international.org/ecma-262/7.0/#global-object) 的 Boolean 属性的初始值。当作为一个构造函数调用时，创建并初始化一个新的 Boolean 对象。当 Boolean 作为一个函数而不是构造函数调用时，它执行类型转换。

Boolean 构造函数设计为可子类化。 它可以用作类定义的extends子句的值。打算继承指定 Boolean 行为的子类构造函数必须包含对 Boolean 构造函数的 super 调用，以便使用[[BooleanData]]内部属性值创建和初始化子类实例。



#### 19.3.1.1 Boolean ( <var>value</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-boolean-constructor-boolean-value)


当使用 value 参数调用 Boolean 时，将执行以下步骤：

1.  令 <var>b</var> 为 [ToBoolean](http://www.ecma-international.org/ecma-262/7.0/#sec-toboolean) (<var>value</var>)。
2.  如果 NewTarget 为 undefined, 返回 <var>b</var>。
3.  令 <var>O</var> = [OrdinaryCreateFromConstructor](http://www.ecma-international.org/ecma-262/7.0/#sec-ordinarycreatefromconstructor) (NewTarget, `"%BooleanPrototype%"`, « [[BooleanData]] »)。
4.  将 <var>O</var>'s [[BooleanData]] 内部属性值设置为b。
5.  返回 <var>O</var>。



### 19.3.2 Boolean 构造函数的属性 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-boolean-constructor)

Boolean 构造函数的 [[Prototype]] 内置属性的值是内置对象 [%FunctionPrototype%](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-function-prototype-object)。
Boolean 构造函数有以下属性：


#### 19.3.2.1 Boolean.prototype [#](http://www.ecma-international.org/ecma-262/7.0/#sec-boolean.prototype)

Boolean.prototype 的初始值是 [%BooleanPrototype%](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-boolean-prototype-object) 内置对象。

这个属性拥有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.



### 19.3.3 Boolean Prototype 对象属性 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-boolean-prototype-object)


Boolean prototype 对象是内置对象 %BooleanPrototype%。 Boolean prototype 对象是一个普通对象。Boolean prototype 本身是一个 Boolean 对象，它有一个属性为 false 的 BooleanData 内置属性。

Boolean prototype 对象的 [[Prototype]] 值是内在对象[%ObjectPrototype%](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-object-prototype-object)。


#### 19.3.3.1 thisBooleanValue ( <var>value</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-thisbooleanvalue)


抽象操作 thisBooleanValue(<var>value</var>)  执行以下步骤：


1.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>value</var>) 为 Boolean, 返回 <var>value</var>。
2.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>value</var>) 是 Object 并且 <var>value</var>  拥有 [[BooleanData]] 内置属性值, 那么
    1.  断言: <var>value</var>'s 内置对象 [[BooleanData]] 是 Boolean 值。
    2.  返回 <var>value</var>'s [[BooleanData]] 内置属性的值。
3.  抛出 TypeError 异常。



#### 19.3.3.2 Boolean.prototype.constructor [#](http://www.ecma-international.org/ecma-262/7.0/#sec-boolean.prototype.constructor)

Boolean.prototype.constructor 的初始值是内置对象[%Boolean%](http://www.ecma-international.org/ecma-262/7.0/#sec-boolean-constructor)。



#### 19.3.3.3 Boolean.prototype.toString ( ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-boolean.prototype.tostring)


将执行以下步骤：

1.  令 <var>b</var> 为 [thisBooleanValue](http://www.ecma-international.org/ecma-262/7.0/#sec-thisbooleanvalue) (this value)。
2.  如果 <var>b</var> 为 true, 返回 `"true"`; 否则返回 `"false"`.



#### 19.3.3.4 Boolean.prototype.valueOf ( ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-boolean.prototype.valueof)


将执行以下步骤

1.  返回[thisBooleanValue](http://www.ecma-international.org/ecma-262/7.0/#sec-thisbooleanvalue) (this value)。


### 19.3.4 Boolean 实例属性 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-boolean-instances)

Boolean 实例是普通对象，从 Boolean prototype 对象继承属性。 Boolean 实例有 [[BooleanData]] 内置属性。[[Boolean Data]]内部属性是由此 Boolean 对象表示的 Boolean 值。




## 19.4 Symbol 对象 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol-objects)



### 19.4.1 Symbol 构造函数 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol-constructor)

Symbol 构造函数是 %Symbol% 内置对象，是 [全局对象](http://www.ecma-international.org/ecma-262/7.0/#global-object) 的 Symbol 属性的初始值。 当 Symbol 作为一个函数被调用时返回一个新的Symbol value。


Symbol构造函数 不用于与 new 运算符一起使用或被子类化，它可以用作类定义的extends子句的值，但是对 Symbol 构造函数的 super 调用将导致异常。



#### 19.4.1.1 Symbol ( [ <var>description</var> ] ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol-description)


当使用可选参数 <var>description</var> 调用 Symbol 时，将执行以下步骤：


1.  如果 NewTarget 不是 undefined, 抛出 TypeError 异常。
2.  如果 <var>description</var> 为 undefined, 令 <var>descString</var> 为 undefined。
3.  否则, 令 <var>descString</var> 为 [ToString](http://www.ecma-international.org/ecma-262/7.0/#sec-tostring) (<var>description</var>)。
4.  返回 一个新的唯一的 Symbol value ，它的 [[Description]] 值为 <var>descString</var>。



### 19.4.2 Properties of the Symbol Constructor [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-symbol-constructor)

Symbol 构造函数的 [[Prototype]] 内置属性的值是内置对象 [%FunctionPrototype%](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-function-prototype-object)。

Symbol 构造函数拥有以下属性:



#### 19.4.2.1 Symbol.for ( <var>key</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.for)


当使用参数 <var>key</var> 调用 Symbol.for 时将执行以下步骤：


1.  令 <var>stringKey</var> 为 [ToString](http://www.ecma-international.org/ecma-262/7.0/#sec-tostring) (<var>key</var>)。
2.  对于 GlobalSymbolRegistry [List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type) 的每个元素<var>e</var>,
    1.  如果 [SameValue](http://www.ecma-international.org/ecma-262/7.0/#sec-samevalue) (<var>e</var>.[[Key]], <var>stringKey</var>) 为 true, 返回 <var>e</var>.[[Symbol]].
3.  断言: GlobalSymbolRegistry 当前不包含 <var>stringKey</var> 的条目。
4.  令 <var>newSymbol</var> 为一个新的唯一 Symbol value ，它的 [[Description]] 值 为<var>stringKey</var>。
5.  把 [Record](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type)  { [[Key]]: <var>stringKey</var>, [[Symbol]]: <var>newSymbol</var> } 附加到 GlobalSymbolRegistry [List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type)。
6.  返回 <var>newSymbol</var>。


GlobalSymbolRegistry 是一个全局的 [List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type) 。 它被所有领域共享。
在执行任何ECMAScript代码之前，它被初始化为一个新的空 [List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type) . GlobalSymbolRegistry 的元素是拥有在 [Table 45](http://www.ecma-international.org/ecma-262/7.0/#table-44) 中定义的数据结构的[Record].


<figure>

<figcaption>表 45: GlobalSymbolRegistry [Record](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type)  字段</figcaption>

| 字段名 | 字段值 | 用途 |
| [[Key]] | A String | 一个用来全局表示 Symbol 的字符串 key。 |
| [[Symbol]] | A Symbol | 可以从[任何领域](http://www.ecma-international.org/ecma-262/7.0/#realm)检索的Symbol。|

</figure>


#### 19.4.2.2 Symbol.hasInstance [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.hasinstance)

Symbol.hasInstance 的初始值是众所周知的 symbol @@hasInstance ([表 1](http://www.ecma-international.org/ecma-262/7.0/#table-1) )。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。



#### 19.4.2.3 Symbol.isConcatSpreadable [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.isconcatspreadable)

Symbol.isConcatSpreadable 的初始值是众所周知的 symbol @@isConcatSpreadable ([表 1](http://www.ecma-international.org/ecma-262/7.0/#table-1) )。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。



#### 19.4.2.4 Symbol.iterator [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.iterator)

Symbol.iterator 的初始值是众所周知的 symbol @@iterator ([表 1](http://www.ecma-international.org/ecma-262/7.0/#table-1) )。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。



#### 19.4.2.5 Symbol.keyFor ( <var>sym</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.keyfor)


当使用参数 <var>sym</var> 调用 Symbol.keyFor 时，执行以下步骤：


1.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>sym</var>) 不是 Symbol, 抛出 TypeError 异常。
2.  对于 GlobalSymbolRegistry [List](http://www.ecma-international.org/ecma-262/7.0/#sec-list-and-record-specification-type)  (参见 [19.4.2.1](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.for) ) 中的每个元素<var>e</var>,
    1.  如果 [SameValue](http://www.ecma-international.org/ecma-262/7.0/#sec-samevalue) (<var>e</var>.[[Symbol]], <var>sym</var>) 为 true, 返回 <var>e</var>.[[Key]]。
3.  断言: GlobalSymbolRegistry 目前不包含 <var>sym</var> 的任何条目。
4.  返回 undefined。



#### 19.4.2.6 Symbol.match [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.match)

Symbol.match 的初始值是众所周知的 symbol @@match ([表 1](http://www.ecma-international.org/ecma-262/7.0/#table-1) )。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。



#### 19.4.2.7 Symbol.prototype [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.prototype)

Symbol.prototype 的初始值是内置对象 [%SymbolPrototype%](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-symbol-prototype-object)。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。



#### 19.4.2.8 Symbol.replace [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.replace)

Symbol.replace 的初始值是众所周知的 symbol @@replace ([表 1](http://www.ecma-international.org/ecma-262/7.0/#table-1) )。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。



#### 19.4.2.9 Symbol.search [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.search)

Symbol.search 的初始值是众所周知的 symbol @@search ([表 1](http://www.ecma-international.org/ecma-262/7.0/#table-1) )。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。



#### 19.4.2.10 Symbol.species [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.species)

Symbol.species 的初始值是众所周知的 symbol @@species ([表 1](http://www.ecma-international.org/ecma-262/7.0/#table-1) )。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。



#### 19.4.2.11 Symbol.split [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.split)

Symbol.split 的初始值是众所周知的 symbol @@split ([表 1](http://www.ecma-international.org/ecma-262/7.0/#table-1) )。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.



#### 19.4.2.12 Symbol.toPrimitive [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.toprimitive)

Symbol.toPrimitive 的初始值是众所周知的 symbol @@toPrimitive ([表 1](http://www.ecma-international.org/ecma-262/7.0/#table-1) )。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。



#### 19.4.2.13 Symbol.toStringTag [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.tostringtag)

Symbol.toStringTag 的初始值是中所周知的 symbol @@toStringTag ([表 1](http://www.ecma-international.org/ecma-262/7.0/#table-1) )。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。



#### 19.4.2.14 Symbol.unscopables [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.unscopables)

Symbol.unscopables 的初始值是众所周知的 symbol @@unscopables ([表 1](http://www.ecma-international.org/ecma-262/7.0/#table-1)。
这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。


### 19.4.3 Symbol Prototype 对象的属性 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-symbol-prototype-object)

Symbol prototype 对象是内置对象 %SymbolPrototype%。 Symbol prototype 对象是一个普通的对象。它不是一个Symbol 实例，不包含 [[SymbolData]] 内置属性值。

[[Prototype]] 内部属性的值是内置对象 [%ObjectPrototype%](http://www.ecma-
international.org/ecma-262/7.0/#sec-properties-of-the-object-prototype-object)。



#### 19.4.3.1 Symbol.prototype.constructor [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.prototype.constructor)

Symbol.prototype.constructor 的初始值是内置对象 [%Symbol%](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol-constructor)。



#### 19.4.3.2 Symbol.prototype.toString ( ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.prototype.tostring)


将执行以下步骤：


1.  令 this 的值 为<var>s</var>。
2.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>s</var>) 为 Symbol, 令 <var>sym</var> 为 <var>s</var>。
3.  否则,
    1.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values)(<var>s</var>) 不是 Object, 抛出 TypeError 异常。
    2.  如果 <var>s</var> 没有 [[SymbolData]] 内置属性, 抛出 TypeError 异常。
    3.  令 <var>sym</var>  <var>s</var>'s [[SymbolData]] 内置属性的值。
4.  返回 [SymbolDescriptiveString](http://www.ecma-international.org/ecma-262/7.0/#sec-symboldescriptivestring) (<var>sym</var>。



##### 19.4.3.2.1 Runtime Semantics: SymbolDescriptiveString ( <var>sym</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symboldescriptivestring)


当使用参数 <var>sym</var> 调用抽象操作 SymbolDescriptiveString，将执行以下步骤：


1.  断言: [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>sym</var>) 为 Symbol。
2.  令 <var>desc</var> 为 <var>sym</var>'s [[Description]] 值。
3.  如果 <var>desc</var> 为 undefined, 令 <var>desc</var> 为空字符串。
4.  断言: [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>desc</var>) 为 String。
5.  返回 "Symbol(", <var>desc</var>, 和 ")" 连接的结果。



#### 19.4.3.3 Symbol.prototype.valueOf ( ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.prototype.valueof)


将执行以下步骤：

1.  令 <var>s</var> 为 this 值。
2.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>s</var>) 为 Symbol, 返回 <var>s</var>.
3.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>s</var>) 不是 Object, 抛出 TypeError 异常。
4.  如果 <var>s</var> 没有 [[SymbolData]] 内置属性, 抛出 TypeError 异常。
5.  返回 <var>s</var>'s [[SymbolData]] 内置属性的值。



#### 19.4.3.4 Symbol.prototype [ @@toPrimitive ]( <var>hint</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.prototype-@@toprimitive)

此函数由ECMAScript语言运算符调用，以将Symbol对象转换为原始值。 <var>hint</var>  允许为 `"default"`, `"number"`, 和 `"string"`。


当使用参数 <var>hint</var> 调用 @@toPrimitive 方法时，将执行以下步骤：

1.  令 <var>s</var> 为 this 值。
2.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>s</var>) is Symbol, 返回 <var>s</var>。
3.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>s</var>) 不是 Object, 抛出 TypeError 异常。
4.  如果 <var>s</var> 没有 [[SymbolData]] 内置属性, 抛出 TypeError 异常。
5.  返回 <var>s</var> 的 [[SymbolData]] 内置属性的值。



The value of the `name` property of this function is `"[Symbol.toPrimitive]"`.

This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.



#### 19.4.3.5 Symbol.prototype [ @@toStringTag ] [#](http://www.ecma-international.org/ecma-262/7.0/#sec-symbol.prototype-@@tostringtag)

@@toStringTag 属性的初始值是字符串 "Symbol"。


这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }。



### 19.4.4 Properties of Symbol Instances [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-symbol-instances)

Symbol 实例是从 Symbol prototype 对象继承属性的普通对象。Symbol 示例拥有 [[SymbolData]] 内置属性。 [[SymbolData]] 内置属性是由 Symbol 对象表示的 Symbol 值。


## 19.5 Error Objects [#](http://www.ecma-international.org/ecma-262/7.0/#sec-error-objects)


 Error对象的实例在运行时遇到错误的情况下会被当做异常抛出。Error对象也可以作为用户自定义异常类的基对象。


### 19.5.1 Error 构造函数 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-error-constructor)

Error 构造函数是 %Error% 内置对象， 是 [全局对象](http://www.ecma-international.org/ecma-262/7.0/#global-object) 的 Error 属性的初始值。 当Error 被当做一个函数而不是构造函数调用时，它创建并初始化一个新的 Error 对象。因此， Error(...)
函数调用等价于使用相同的参数调用对象创建表达式 new Error(...)。


Error 构造函数被设计为可以子类化。它可以作为 class 定义的 extends 子句的值。打算继承指定 Error 行为的子类，必须包含一个对 Error 构造函数的 super 调用，用来创建并初始化拥有 [[ErrorData]] 内置属性的子类实例。




#### 19.5.1.1 Error ( <var>message</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-error-message)


当使用 <var>message</var> 参数调用 Error 函数时，将执行以下步骤：

1.  如果 NewTarget 为 undefined, 令 <var>newTarget</var> 为 [活动函数对象](http://www.ecma-international.org/ecma-262/7.0/#active-function-object) , 否则 令 <var>newTarget</var> 为 NewTarget。
2.  令 <var>O</var> 为 [OrdinaryCreateFromConstructor](http://www.ecma-international.org/ecma-262/7.0/#sec-ordinarycreatefromconstructor) (<var>newTarget</var>, `"%ErrorPrototype%"`, « [[ErrorData]] »)。
3.  如果 <var>message</var> 不是 undefined, 那么
    1.  令 <var>msg</var> 为 [ToString](http://www.ecma-international.org/ecma-262/7.0/#sec-tostring) (<var>message</var>)。
    2.  令 <var>msgDesc</var> 为  PropertyDescriptor{[[Value]]: <var>msg</var>, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}。
    3.  执行 [DefinePropertyOrThrow](http://www.ecma-international.org/ecma-262/7.0/#sec-definepropertyorthrow) (<var>O</var>, `"message"`, <var>msgDesc</var>)。
4.  返回 <var>O</var>。



### 19.5.2 Error 构造函数的属性 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-error-constructor)

Error 构造函数的 [[Prototype]] 内置属性的值是内置对象 [%FunctionPrototype%](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-function-prototype-object) 。

Error 构造函数拥有以下属性：



#### 19.5.2.1 Error.prototype [#](http://www.ecma-international.org/ecma-262/7.0/#sec-error.prototype)

Error.prototype 的初始值是内置对象[%ErrorPrototype%](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-error-prototype-object)。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。



### 19.5.3 Error Prototype 对象的属性 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-error-prototype-object)

Error prototype 对象是内置对象 %ErrorPrototype%。 Error prototype 对象是一个普通对象。它不是一个  Error 实例也没有 [[ErrorData]] 内置属性。

Error prototype 对象的 [[Prototype]] 内置对象的值是内在对象 [%ObjectPrototype%](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-object-prototype-object)。



#### 19.5.3.1 Error.prototype.constructor [#](http://www.ecma-international.org/ecma-262/7.0/#sec-error.prototype.constructor)

Error.prototype.constructor 的初始值 是内在对象 [%Error%](http://www.ecma-international.org/ecma-262/7.0/#sec-error-constructor)。



#### 19.5.3.2 Error.prototype.message [#](http://www.ecma-international.org/ecma-262/7.0/#sec-error.prototype.message)

Error.prototype.message 的初始值是空字符串。



#### 19.5.3.3 Error.prototype.name [#](http://www.ecma-international.org/ecma-262/7.0/#sec-error.prototype.name)

Error.prototype.name 的初始值是 "Error"。



#### 19.5.3.4 Error.prototype.toString ( ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-error.prototype.tostring)

将执行以下步骤：


1.  令 <var>O</var> 为 this 值。
2.  如果 [Type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values) (<var>O</var>) 不是 Object, 抛出 TypeError 异常。
3.  令 <var>name</var> 为 [Get](http://www.ecma-international.org/ecma-262/7.0/#sec-get-o-p) (<var>O</var>, "name")。
4.  如果 <var>name</var> 为 undefined,  令 <var>name</var> 为 "Error"; 否则 令 <var>name</var> 为 [ToString](http://www.ecma-international.org/ecma-262/7.0/#sec-tostring) (<var>name</var>)。
5.  令 <var>msg</var> 为 [Get](http://www.ecma-international.org/ecma-262/7.0/#sec-get-o-p) (<var>O</var>, "message")。
6.  如果 <var>msg</var> 为 undefined, 令 <var>msg</var> 为空字符串; 否则 令 <var>msg</var> 为 [ToString](http://www.ecma-international.org/ecma-262/7.0/#sec-tostring) (<var>msg</var>)。
7.  如果 <var>name</var> 是空字符串, 返回 <var>msg</var>。
8.  如果 <var>msg</var> 是空字符串, 返回 <var>name</var>。
9.  返回<var>name</var>, 代码单元 0x003A (冒号), 代码单元 0x0020 (空格), 和 <var>msg</var> 连接的结果.



### 19.5.4 Properties of Error Instances [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-error-instances)

Error 实例是从 Error prototype 对象继承了属性的普通对象，拥有值为 undefined 的 [[ErrorData]] 内在属性。[[ErrorData]]的唯一指定用途是将 Error和 NativeError 实例标识为 Object.prototype.toString 中的错误对象。



### 19.5.5 Native Error Types Used in This Standard [#](http://www.ecma-international.org/ecma-262/7.0/#sec-native-error-types-used-in-this-standard)

当检测到运行时错误时，以下 NativeError 对象之一的实例会被抛出， 所有的这些对象共享同样的结构, 如[19.5.6](http://www.ecma-international.org/ecma-262/7.0/#sec-nativeerror-object-structure)所述。



#### 19.5.5.1 EvalError [#](http://www.ecma-international.org/ecma-262/7.0/#sec-native-error-types-used-in-this-standard-evalerror)

本规范现在已经不再使用这个异常，这个对象用于和规范之前版本的保持兼容性而保留。


#### 19.5.5.2 RangeError [#](http://www.ecma-international.org/ecma-262/7.0/#sec-native-error-types-used-in-this-standard-rangeerror)

表示不在允许值的集合或范围内的值。



#### 19.5.5.3 ReferenceError [#](http://www.ecma-international.org/ecma-262/7.0/#sec-native-error-types-used-in-this-standard-referenceerror)


表示检测到一个不正确的引用值。


#### 19.5.5.4 SyntaxError [#](http://www.ecma-international.org/ecma-262/7.0/#sec-native-error-types-used-in-this-standard-syntaxerror)


表示发生一个解析错误。



#### 19.5.5.5 TypeError [#](http://www.ecma-international.org/ecma-262/7.0/#sec-native-error-types-used-in-this-standard-typeerror)


TypeError用于在没有其他 适当 NativeError 指示对象故障原因时,指示不成功的操作。



#### 19.5.5.6 URIError [#](http://www.ecma-international.org/ecma-262/7.0/#sec-native-error-types-used-in-this-standard-urierror)


表示其中一个全局URI处理函数的使用方式与其定义不兼容。


#### 19.5.6<var>NativeError</var> 对象结构  [#](http://www.ecma-international.org/ecma-262/7.0/#sec-nativeerror-object-structure)

当ECMAScript实现检测到运行时错误时，它会抛出 [19.5.5](http://www.ecma-international.org/ecma-262/7.0/#sec-native-error-types-used-in-this-standard)中定义的一个NativeError对象的新实例。 这些对象中的每一个具有下面描述的结构，区别仅限 prototype 对象的 name 属性 被用作构造函数的名字而不是 NativeError，以及 prototype 对象 的 message 属性的定义实现方式。

对于每个错误对象，定义中对NativeError的引用应该替换为来自 [19.5.5](http://www.ecma-international.org/ecma-262/7.0/#sec-native-error-types-used-in-this-standard) 的适当的错误对象名称。

#### 19.5.6.1<var>NativeError</var> 构造函数 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-nativeerror-constructors)

当一个 NativeError 构造函数作为函数而不是作为构造函数调用时，它会创建并初始化一个新的 NativeError对象。对象作为一个函数的调用等同于将它作为具有相同参数的构造函数的调用。因此NativeError(…) 函数调用等价于具有相同参数的对象创建表达式 new NativeError(…)。


每个 NativeError 构造函数设计为可子类化。它可以用作类定义的extends子句的值。 打算继承指定的 NativeError 行为的子类构造函数必须包含对 NativeError 构造函数的 super 调用，以创建并初始化具有 [[ErrorData]] 内部属性的子类实例 。



##### 19.5.6.1.1 NativeError ( <var>message</var> ) [#](http://www.ecma-international.org/ecma-262/7.0/#sec-nativeerror)


当使用参数  <var>message</var> 调用 NativeError 函数时，将执行以下步骤：



1.  如果 NewTarget 为 undefined, 令 <var>newTarget</var> 为 [活动函数对象](http://www.ecma-international.org/ecma-262/7.0/#active-function-object) , 否则 令 <var>newTarget</var> 为 NewTarget。
2.  令 <var>O</var> 为 [OrdinaryCreateFromConstructor](http://www.ecma-international.org/ecma-262/7.0/#sec-ordinarycreatefromconstructor) (<var>newTarget</var>, `"%<var>NativeError</var>Prototype%"`, « [[ErrorData]] »)。
3.  如果 <var>message</var> 不是 undefined, 那么
    1.  令 <var>msg</var> 为 [ToString](http://www.ecma-international.org/ecma-262/7.0/#sec-tostring) (<var>message</var>)。
    2.  令 <var>msgDesc</var> 为 PropertyDescriptor{[[Value]]: <var>msg</var>, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}。
    3.  执行 [DefinePropertyOrThrow](http://www.ecma-international.org/ecma-262/7.0/#sec-definepropertyorthrow) (<var>O</var>, `"message"`, <var>msgDesc</var>)。
4.  返回 <var>O</var>。



在步骤2中传递的字符串的实际值是 “％EvalErrorPrototype％”，”％RangeErrorPrototype％“，“％ReferenceErrorPrototype％”，“％SyntaxErrorPrototype％”，“％TypeErrorPrototype％” 或者 “％URIErrorPrototype％” 对应的<var> NativeError </ var>构造函数。



#### 19.5.6.2 Properties of the <var>NativeError</var> Constructors [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-nativeerror-constructors)

<var>NativeError</var> 构造函数 [[Prototype]] 内置属性的值是内在对象[%Error%](http://www.ecma-international.org/ecma-262/7.0/#sec-error-constructor)。

每个 <var>NativeError</var> 构造函数拥有一个值为字符串 "NativeError" 的 name 属性。

每个 <var>NativeError</var> 构造函数拥有以下属性:



##### 19.5.6.2.1 NativeError.prototype [#](http://www.ecma-international.org/ecma-262/7.0/#sec-nativeerror.prototype)

<var>NativeError</var>.prototype 的初始值是 <var>NativeError</var> prototype 对象 ([19.5.6.3](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-nativeerror-prototype-objects) )。 每个 <var>NativeError</var> 构造函数拥有不同的 prototype 对象。

这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。



#### 19.5.6.3 Properties of the <var>NativeError</var> Prototype Objects [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-nativeerror-prototype-objects)

每个 <var>NativeError</var> prototype 对象是一个普通对象。 它不是 Error 实例并且没有[[ErrorData]] 内置属性。

每个 <var>NativeError</var> prototype 对象的 [[Prototype]] 内置属性的值是内在对象[%ErrorPrototype%](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-error-prototype-object)。


##### 19.5.6.3.1<var>NativeError</var>.prototype.constructor [#](http://www.ecma-international.org/ecma-262/7.0/#sec-nativeerror.prototype.constructor)


给定 NativeError 构造函数的 prototype 的constructor 属性的初始值是相应的内在对象％NativeError％（[19.5.6.1](http://www.ecma-international.org/ecma-262/7.0/#sec-nativeerror-constructors)）。


##### 19.5.6.3.2<var>NativeError</var>.prototype.message [#](http://www.ecma-international.org/ecma-262/7.0/#sec-nativeerror.prototype.message)


对于一个给定的 <var>NativeError</var> 构造函数的prototype 的 message 属性初始值是空字符串。


##### 19.5.6.3.3<var>NativeError</var>.prototype.name [#](http://www.ecma-international.org/ecma-262/7.0/#sec-nativeerror.prototype.name)


对于一个给定的 <var>NativeError</var> 的 prototype 的name属性的初始值是由构造函数的名称（使用的名称而不是Native Error）组成的字符串。

#### 19.5.6.4 <var>NativeError</var> 实例的属性 [#](http://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-nativeerror-instances)

<var>NativeError</var> 实例是从它的 <var>NativeError</var> prototype 对象继承了属性的普通对象，拥有一个 value 为 undefined 的内置属性[[ErrorData]]。 [[Error Data]]的唯一指定用法是通过Object.prototype.toString（[19.1.3.6](http://www.ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)）来标识 Error 或<var>NativeError</var> 实例。
